<!DOCTYPE html>
<html lang = "en">

<head>
	<meta charset="UTF-8">
	<meta name = "viewport" content="width=device-width, initial-scale = 1.0">
	<title>ThreeJS asg5</title>
</head>

<style>
	html, body {
		margin: 0;
		height: 100%;
	}
	#c {
		width: 100%;
		height: 100%;
		display: block;
	}

</style>

<body>
<canvas id="c"></canvas>
</body>

<script type="importmap">
{
  "imports": {
    "three": "./build/three.module.js"
  }
}
</script>

<script type="module">
	import * as THREE from 'three';
	import {OrbitControls} from './examples/jsm/controls/OrbitControls.js';
	import {OBJLoader} from './examples/jsm/loaders/OBJLoader.js';
	import {MTLLoader} from './examples/jsm/loaders/MTLLoader.js';

	// extra: fog, billboards and render target
	// light: HemisphereLight, DirectionalLight, PointLight and SpotLight
	function main() {
		const canvas = document.querySelector('#c');
		const renderer = new THREE.WebGLRenderer({canvas});
		renderer.outputEncoding = THREE.sRGBEncoding;

		const fov = 70;
		const aspect = 2;  // the canvas default
		const near = 0.1;
		const far = 100;
		const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		camera.position.set(0, 10, 35);

		//move the camera with orbit controls
		const controls = new OrbitControls(camera, canvas);
		controls.target.set(0, 5, 0);
		controls.update();

		const scene = new THREE.Scene();
		//scene.background = new THREE.Color('LightBlue');

		// Cite
		// Sky/Cloud boxes created by Zachery "skiingpenguins" Slocum
		// link: https://opengameart.org/content/spacemoon-skybox
		{
			{
				const loader = new THREE.CubeTextureLoader();
				const BGtexture = loader.load([
					'resources/penguins/indigo_ft.jpg',
					'resources/penguins/indigo_bk.jpg',
					'resources/penguins/indigo_up.jpg',
					'resources/penguins/indigo_dn.jpg',
					'resources/penguins/indigo_rt.jpg',
					'resources/penguins/indigo_lf.jpg',
				]);
				scene.background = BGtexture;
			}
		}

		// fog
		{
			const color = 0xFFFFFF;  // white
			const near = 5;
			const far = 100;
			scene.fog = new THREE.Fog(color, near, far);
		}

		//ground
		{
			const planeSize = 80;
			const loader = new THREE.TextureLoader();
			const texture = loader.load('resources/tex1.jpg');
			texture.encoding = THREE.sRGBEncoding;
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;
			texture.magFilter = THREE.NearestFilter;
			const repeats = planeSize / 2;
			texture.repeat.set(repeats, repeats);

			const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
			const planeMat = new THREE.MeshPhongMaterial({
				map: texture,
				side: THREE.DoubleSide,
			});
			const mesh = new THREE.Mesh(planeGeo, planeMat);
			mesh.rotation.x = Math.PI * -.5;
			scene.add(mesh);
		}

			// sphere
		{
			const sphereRadius = 2;
			const sphereWidthDivisions = 32;
			const sphereHeightDivisions = 16;
			const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
			const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
			const mesh = new THREE.Mesh(sphereGeo, sphereMat);
			mesh.position.set(-5, 2, 8);
			scene.add(mesh);

			makeBillboards(-5, 2+2.5, 8, 100, 32, 'Ball');
		}


		// HemisphereLight
		{
			const skyColor = 0xB1E1FF;  // light blue
			const groundColor = 0xCC33CC;	// light purple&pink
			const intensity = 0.45;
			const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
			scene.add(light);
		}

		// DirectionalLight
		{
			const color = 0xB1E1FF;
			const intensity = 0.8;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(5, 6, 0);
			light.target.position.set(5, 5, 0);
			scene.add(light);
			scene.add(light.target);
		}

		// PointLight
		{
			//const color = 0x5DADE2;
			const color = 0xA8A8A8;
			const intensity = 0.89;
			const light = new THREE.PointLight(color, intensity);
			light.position.set(0, -5, 0);
			scene.add(light);
		}

		//spotLight
		{
			const color = 0xFFFFFF;
			const intensity = 0.7;
			const light = new THREE.SpotLight(color, intensity);
			light.position.set(0, 8, 0);
			light.target.position.set(0, 0, 0);
			scene.add(light);
			scene.add(light.target);
		}

		//3d obj
		//Cite
		//Source from: https://blendswap.com/blend/17635  , Creator: Angel23Barriga
		{
			const objLoader = new OBJLoader();
			objLoader.load('resources/Lugia1/Lugia1.obj', (root) => {
				scene.add(root);
			});
			const mtlLoader = new MTLLoader();
			mtlLoader.load('resources/Lugia1/Lugia1.mtl', (mtl) => {
				mtl.preload();
				objLoader.setMaterials(mtl);
				objLoader.load('resources/Lugia1/Lugia1.obj', (root) => {
					scene.add(root);
				});
			});
		}

		// cubes
		const boxWidth = 5;
		const boxHeight = 5;
		const boxDepth = 5;
		const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

		function makeInstance(geometry, x,y,z) {
			const loader = new THREE.TextureLoader();
			const material = new THREE.MeshPhongMaterial({
				map: loader.load('resources/tex2.jpg'),
			});

			const cube = new THREE.Mesh(geometry, material);
			scene.add(cube);

			cube.position.x = x;
			cube.position.y = y;
			cube.position.z = z;

			makeBillboards(x, y+5, z, 800, 100, 'rotatable cube');

			return cube;
		}

		const cubes = [
			makeInstance(geometry,  20,5,-20),
			makeInstance(geometry,  -20,5,-20)
		];

		//-----render targets-----
		const rtWidth = 512;
		const rtHeight = 512;
		const renderTarget = new THREE.WebGLRenderTarget(rtWidth, rtHeight);

		const rtFov = 70;
		const rtAspect = rtWidth / rtHeight;
		const rtNear = 0.2;
		const rtFar = 6;
		const rtCamera = new THREE.PerspectiveCamera(rtFov, rtAspect, rtNear, rtFar);
		rtCamera.position.z = 3;

		const rtScene = new THREE.Scene();
		rtScene.background = new THREE.Color('Cyan');
		{
			const color = 0xFFFFFF;
			const intensity = 1.1;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(-2, 3, 3);
			rtScene.add(light);
		}

		const Oct3radius = 1;  // ui: radius
		const Oct3geometry = new THREE.OctahedronGeometry(Oct3radius);

		const Oct3 = new THREE.Mesh(Oct3geometry);

		function Oct3makeInstance(Oct3geometry, color, x) {
			const material = new THREE.MeshPhongMaterial({color});
			const Oct3 = new THREE.Mesh(Oct3geometry, material);
			rtScene.add(Oct3);
			Oct3.position.x = x;
			return Oct3;
		}

		const rtOct = [
			Oct3makeInstance(Oct3geometry, 0xc7bbc9, -1),
			Oct3makeInstance(Oct3geometry, 0xc7bbc9, 1)
		];

		const material = new THREE.MeshPhongMaterial({
			map: renderTarget.texture,
		});

		const cube3geometry = new THREE.BoxGeometry(3, 3, 3);
		const cube = new THREE.Mesh(cube3geometry, material);
		cube.position.set(5, 2.45, 8);
		scene.add(cube);
		//-------------end----------------

		//Oct1
		const radius = 1;  // ui: radius
		const geometry2 = new THREE.OctahedronGeometry(radius);

		function makeInstance2(geometry2, x, y, z) {
			const loader = new THREE.TextureLoader();
			const material = new THREE.MeshPhongMaterial({
				map: loader.load('resources/ice7.jpg'),
			});

			const Oct = new THREE.Mesh(geometry2, material);
			scene.add(Oct);

			Oct.position.x = x;
			Oct.position.y = y;
			Oct.position.z = z;
			return Oct;
		}

		const Oct = [
			makeInstance2(geometry2,  3.5,3.5,1),
			makeInstance2(geometry2,  -3.5,3.5,1)
		]

		{//Oct2
			const radius = 2;  // ui: radius
			const geometry2 = new THREE.OctahedronGeometry(radius);

			function makeInstance22(geometry2, x, y, z) {
				const loader = new THREE.TextureLoader();
				const material = new THREE.MeshPhongMaterial({
					map: loader.load('resources/tex1.jpg'),
				});

				const Oct2 = new THREE.Mesh(geometry2, material);
				scene.add(Oct2);

				Oct2.position.x = x;
				Oct2.position.y = y;
				Oct2.position.z = z;
				return Oct2;
			}

			const Oct2 = [
				makeInstance22(geometry2, 8, 5, 6),
				makeInstance22(geometry2, -8, 5, 6),
				makeInstance22(geometry2, 8, 5, -6),
				makeInstance22(geometry2, -8, 5, -6),
			]
		}	//end

		{	//Octa ball
			const radius = 2;  // ui: radius
			const detail = 1;  // ui: detail
			const geometry3 = new THREE.OctahedronGeometry(radius, detail);

			function makeInstance3(geometry3, x, y, z) {
				const loader = new THREE.TextureLoader();
				const material = new THREE.MeshPhongMaterial({
					map: loader.load('resources/ice7.jpg'),
				});

				const Octa = new THREE.Mesh(geometry3, material);
				scene.add(Octa);

				Octa.position.x = x;
				Octa.position.y = y;
				Octa.position.z = z;
				return Octa;
			}

			const Octa = [
				makeInstance3(geometry3, 15, 2, 6),
				makeInstance3(geometry3, -15, 2, 6),
				makeInstance3(geometry3, 15, 2, -6),
				makeInstance3(geometry3, -15, 2, -6),
			]
		}

		{	//Cone
			const radius = 2;  // ui: radius
			const height = 11.89;  // ui: height
			const radialSegments = 12;  // ui: radialSegments
			const geometry4 = new THREE.ConeGeometry(radius, height, radialSegments);
			function makeInstance4(geometry4, x, y, z) {
				const loader = new THREE.TextureLoader();
				const material = new THREE.MeshPhongMaterial({
					map: loader.load('resources/tex1.jpg'),
				});

				const Cone = new THREE.Mesh(geometry4, material);
				scene.add(Cone);

				Cone.position.x = x;
				Cone.position.y = y;
				Cone.position.z = z;
				return Cone;
			}

				const Cone = [
					makeInstance4(geometry4, -12, 6, -12),
					makeInstance4(geometry4, -8, 6, -12),
					makeInstance4(geometry4, -4, 6, -12),
					makeInstance4(geometry4, 0, 6, -12),
					makeInstance4(geometry4, 4, 6, -12),
					makeInstance4(geometry4, 8, 6, -12),
					makeInstance4(geometry4, 12, 6, -12),
					makeInstance4(geometry4, 20, 6, 20),
					makeInstance4(geometry4, -20, 6, 20),
				]
		}

			//Cylin
			const radiusTop = 2;  // ui: radiusTop
			const radiusBottom = 2;  // ui: radiusBottom
			const height = 5.9;  // ui: height
			const radialSegments = 12;  // ui: radialSegments
			const geometry5 = new THREE.CylinderGeometry(
					radiusTop, radiusBottom, height, radialSegments);

			function makeInstance5(geometry5, x, y, z) {
				const loader = new THREE.TextureLoader();
				const material = new THREE.MeshPhongMaterial({
					map: loader.load('resources/tex4.jpg'),
				});

				const Cylin = new THREE.Mesh(geometry5, material);
				scene.add(Cylin);

				Cylin.position.x = x;
				Cylin.position.y = y;
				Cylin.position.z = z;
				makeBillboards(x, y+5, z, 200, 35, 'ice cylinder');
				return Cylin;
			}

			const Cylin = [
				makeInstance5(geometry5, -8, 3, 20),
				makeInstance5(geometry5, 8, 3, 20),
			]

		// make label
		function makeLabelCanvas(baseWidth, size, name) {
			const borderSize = 2;
			const ctx = document.createElement('canvas').getContext('2d');
			const font =  `${size}px bold sans-serif`;
			ctx.font = font;
			// measure how long the name will be
			const textWidth = ctx.measureText(name).width;

			const doubleBorderSize = borderSize * 2;
			const width = baseWidth + doubleBorderSize;
			const height = size + doubleBorderSize;
			ctx.canvas.width = width;
			ctx.canvas.height = height;

			// need to set font again after resizing canvas
			ctx.font = font;
			ctx.textBaseline = 'middle';
			ctx.textAlign = 'center';
			ctx.fillStyle = 'gray';
			ctx.fillRect(0, 0, width, height);

			// scale to fit but don't stretch
			const scaleFactor = Math.min(1, baseWidth / textWidth);
			ctx.translate(width / 2, height / 2);
			ctx.scale(scaleFactor, 1);
			ctx.fillStyle = 'white';
			ctx.fillText(name, 0, 0);

			return ctx.canvas;
		}

		function makeBillboards(x, y, z, labelWidth, size, name) {
			const canvas = makeLabelCanvas(labelWidth, size, name);
			const texture = new THREE.CanvasTexture(canvas);

			texture.minFilter = THREE.LinearFilter;
			//texture.wrapS = THREE.ClampToEdgeWrapping;
			texture.wrapT = THREE.ClampToEdgeWrapping;

			const labelMaterial = new THREE.SpriteMaterial({
				map: texture,
				transparent: true,
			});

			const root = new THREE.Object3D();
			root.position.x = x;

			const label = new THREE.Sprite(labelMaterial);
			root.add(label);
			label.position.y = y
			label.position.z = z;

			// if units are meters then 0.01 here makes size
			// of the label into centimeters.
			const labelBaseScale = 0.01;
			label.scale.x = canvas.width  * labelBaseScale;
			label.scale.y = canvas.height * labelBaseScale;

			scene.add(root);
			return root;
		}

		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
				renderer.setSize(width, height, false);
			}
			return needResize;
		}

		function render(time) {
			time *= 0.001;

			if (resizeRendererToDisplaySize(renderer)) {
				const canvas = renderer.domElement;
				camera.aspect = canvas.clientWidth / canvas.clientHeight;
				camera.updateProjectionMatrix();
			}

			cubes.forEach((cube, ndx) => {
				const speed = 0.1 + ndx * .1;
				let rot = time * speed;
				cube.rotation.x = rot;
			});

			Oct.forEach((oct, ndx) => {
				const speed = 1.5 + ndx * .1;
				let rot = time * speed;
				oct.rotation.x = rot;
				oct.rotation.y = rot;
			});

			Cylin.forEach((Cylin, ndx) => {
				const speed = 0.2 + ndx * .1;
				let rot = time * speed;
				Cylin.rotation.y = rot;
			});


			rtOct.forEach((cube, ndx) => {
				const speed = 1 + ndx * .1;
				const rot = time * speed;
				cube.rotation.x = rot;
				cube.rotation.y = rot;
			});

			cube.rotation.x = time;
			cube.rotation.y = time * 1.1;

			renderer.setRenderTarget(renderTarget);
			renderer.render(rtScene, rtCamera);
			renderer.setRenderTarget(null);

			renderer.render(scene, camera);

			requestAnimationFrame(render);
		}

		requestAnimationFrame(render);
	}

	main();
</script>
</html>



